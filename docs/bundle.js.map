{
  "version": 3,
  "sources": ["../src/index.ts", "../src/cipher.ts", "../src/license.ts"],
  "sourcesContent": ["export { generateLicenseKey, verifyLicenseKey } from './license.js';\r\nexport { CkCipher } from './cipher.js';\r\n", "/**\r\n * RC5-like cipher implementation for Charles license key generation\r\n */\r\n\r\nconst ROUNDS = 12;\r\nconst ROUND_KEYS = 2 * (ROUNDS + 1);\r\n\r\nexport class CkCipher {\r\n  private rk: Int32Array;\r\n\r\n  constructor(ckKey: bigint) {\r\n    this.rk = new Int32Array(ROUND_KEYS);\r\n    this.initializeRoundKeys(ckKey);\r\n  }\r\n\r\n  private initializeRoundKeys(ckKey: bigint): void {\r\n    const ld = new Int32Array(2);\r\n    ld[0] = Number(ckKey & 0xffffffffn);\r\n    ld[1] = Number((ckKey >> 32n) & 0xffffffffn);\r\n\r\n    this.rk[0] = -1209970333;\r\n    for (let i = 1; i < ROUND_KEYS; i++) {\r\n      this.rk[i] = this.rk[i - 1] + -1640531527;\r\n    }\r\n\r\n    let a = 0, b = 0;\r\n    let i = 0, j = 0;\r\n\r\n    for (let k = 0; k < 3 * ROUND_KEYS; k++) {\r\n      this.rk[i] = this.rotateLeft(this.rk[i] + (a + b), 3);\r\n      a = this.rk[i];\r\n      ld[j] = this.rotateLeft(ld[j] + (a + b), a + b);\r\n      b = ld[j];\r\n      i = (i + 1) % ROUND_KEYS;\r\n      j = (j + 1) % 2;\r\n    }\r\n  }\r\n\r\n  encrypt(input: bigint): bigint {\r\n    let a = Number(input & 0xffffffffn) + this.rk[0];\r\n    let b = Number((input >> 32n) & 0xffffffffn) + this.rk[1];\r\n\r\n    for (let r = 1; r <= ROUNDS; r++) {\r\n      a = this.rotateLeft(a ^ b, b) + this.rk[2 * r];\r\n      b = this.rotateLeft(b ^ a, a) + this.rk[2 * r + 1];\r\n    }\r\n\r\n    return this.packLong(a, b);\r\n  }\r\n\r\n  decrypt(input: bigint): bigint {\r\n    let a = Number(input & 0xffffffffn);\r\n    let b = Number((input >> 32n) & 0xffffffffn);\r\n\r\n    for (let i = ROUNDS; i > 0; i--) {\r\n      b = this.rotateRight(b - this.rk[2 * i + 1], a) ^ a;\r\n      a = this.rotateRight(a - this.rk[2 * i], b) ^ b;\r\n    }\r\n\r\n    b -= this.rk[1];\r\n    a -= this.rk[0];\r\n\r\n    return this.packLong(a, b);\r\n  }\r\n\r\n  private rotateLeft(x: number, y: number): number {\r\n    const shift = y & 31;\r\n    return ((x << shift) | (x >>> (32 - shift))) | 0;\r\n  }\r\n\r\n  private rotateRight(x: number, y: number): number {\r\n    const shift = y & 31;\r\n    return ((x >>> shift) | (x << (32 - shift))) | 0;\r\n  }\r\n\r\n  private packLong(a: number, b: number): bigint {\r\n    const aUnsigned = BigInt(a >>> 0);\r\n    const bUnsigned = BigInt(b >>> 0);\r\n    return aUnsigned | (bUnsigned << 32n);\r\n  }\r\n}\r\n", "import { CkCipher } from './cipher.js';\r\n\r\nconst CK_NAME = 0x7a21c951691cd470n;\r\nconst CK_KEY = -5408575981733630035n;\r\n\r\n/**\r\n * Generate a Charles license key for the given name\r\n */\r\nexport function generateLicenseKey(name: string): string {\r\n  const nameBytes = new TextEncoder().encode(name);\r\n  const length = nameBytes.length + 4;\r\n  const padded = length + ((-length) & 7);\r\n  \r\n  // Create buffer with length prefix\r\n  const buffer = new Uint8Array(padded);\r\n  const view = new DataView(buffer.buffer);\r\n  view.setUint32(0, nameBytes.length, false); // Big-endian\r\n  buffer.set(nameBytes, 4);\r\n\r\n  // Encrypt the name using cipher\r\n  const ck = new CkCipher(CK_NAME);\r\n  const outBuffer: number[] = [];\r\n\r\n  for (let i = 0; i < padded; i += 8) {\r\n    const view = new DataView(buffer.buffer, i, 8);\r\n    const nowVar = view.getBigInt64(0, false); // Big-endian\r\n    \r\n    const encrypted = ck.encrypt(nowVar);\r\n    \r\n    // Write 8 bytes\r\n    for (let j = 7; j >= 0; j--) {\r\n      outBuffer.push(Number((encrypted >> BigInt(j * 8)) & 0xffn));\r\n    }\r\n  }\r\n\r\n  // Calculate checksum\r\n  let n = 0;\r\n  for (const b of outBuffer) {\r\n    const signed = b << 24 >> 24; // Convert to signed byte\r\n    n = rotateLeft(n ^ signed, 3);\r\n  }\r\n\r\n  const prefix = n ^ 0x54882f8a;\r\n  const suffix = Math.floor(Math.random() * 0x7fffffff);\r\n  \r\n  let input = BigInt(prefix) << 32n;\r\n  const s = BigInt(suffix);\r\n  const suffixHigh = suffix >> 16;\r\n\r\n  switch (suffixHigh) {\r\n    case 0x0401:\r\n    case 0x0402:\r\n    case 0x0403:\r\n      input |= s;\r\n      break;\r\n    default:\r\n      input |= 0x01000000n | (s & 0xffffffn);\r\n      break;\r\n  }\r\n\r\n  // Decrypt to get final key\r\n  const out = new CkCipher(CK_KEY).decrypt(input);\r\n\r\n  // Calculate validation byte\r\n  let n2 = 0n;\r\n  for (let i = 56; i >= 0; i -= 8) {\r\n    n2 ^= (input >> BigInt(i)) & 0xffn;\r\n  }\r\n\r\n  let vv = Number(n2 & 0xffn);\r\n  if (vv < 0) {\r\n    vv = -vv;\r\n  }\r\n\r\n  return `${vv.toString(16).padStart(2, '0')}${(out & 0xffffffffffffffffn).toString(16).padStart(16, '0')}`;\r\n}\r\n\r\n/**\r\n * Verify a Charles license key for the given name\r\n */\r\nexport function verifyLicenseKey(name: string, key: string): boolean {\r\n  try {\r\n    if (key.length !== 18) {\r\n      return false;\r\n    }\r\n\r\n    // Parse the key - format is: checksum(2) + decrypted_value(16)\r\n    const checkByte = parseInt(key.substring(0, 2), 16);\r\n    const keyHigh = BigInt('0x' + key.substring(2, 10));\r\n    const keyLow = BigInt('0x' + key.substring(10, 18));\r\n    const out = (keyHigh << 32n) | keyLow;\r\n\r\n    // Encrypt 'out' to get back 'in' (the original prefix+suffix)\r\n    const cipher = new CkCipher(CK_KEY);\r\n    const inputValue = cipher.encrypt(out);\r\n\r\n    // Verify checksum - computed on 'in', not 'out'\r\n    let n2 = 0n;\r\n    for (let i = 56; i >= 0; i -= 8) {\r\n      n2 ^= (inputValue >> BigInt(i)) & 0xffn;\r\n    }\r\n    const calculatedCheck = Math.abs(Number(n2 & 0xffn));\r\n    \r\n    if (calculatedCheck !== checkByte) {\r\n      return false;\r\n    }\r\n\r\n    // Extract prefix from input value (upper 32 bits)\r\n    const prefix = Number((inputValue >> 32n) & 0xffffffffn);\r\n    \r\n    // Encode name and calculate expected prefix\r\n    const nameBytes = new TextEncoder().encode(name);\r\n    const length = nameBytes.length + 4;\r\n    const padded = length + ((-length) & 7);\r\n    \r\n    const buffer = new Uint8Array(padded);\r\n    const view = new DataView(buffer.buffer);\r\n    view.setUint32(0, nameBytes.length, false);\r\n    buffer.set(nameBytes, 4);\r\n\r\n    const ck = new CkCipher(CK_NAME);\r\n    const outBuffer: number[] = [];\r\n\r\n    for (let i = 0; i < padded; i += 8) {\r\n      const view = new DataView(buffer.buffer, i, 8);\r\n      const nowVar = view.getBigInt64(0, false);\r\n      const encrypted = ck.encrypt(nowVar);\r\n      \r\n      for (let j = 7; j >= 0; j--) {\r\n        outBuffer.push(Number((encrypted >> BigInt(j * 8)) & 0xffn));\r\n      }\r\n    }\r\n\r\n    let n = 0;\r\n    for (const b of outBuffer) {\r\n      const signed = b << 24 >> 24;\r\n      n = rotateLeft(n ^ signed, 3);\r\n    }\r\n\r\n    const expectedPrefix = (n ^ 0x54882f8a) >>> 0; // Convert to unsigned 32-bit\r\n    \r\n    // Compare as unsigned 32-bit integers\r\n    const prefixUnsigned = (prefix >>> 0);\r\n    return prefixUnsigned === expectedPrefix;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction rotateLeft(x: number, y: number): number {\r\n  const shift = y & 31;\r\n  return ((x << shift) | (x >>> (32 - shift))) | 0;\r\n}\r\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "CkCipher", "generateLicenseKey", "verifyLicenseKey", "CkCipher", "ckKey", "__publicField", "ld", "a", "b", "i", "j", "k", "input", "r", "x", "y", "shift", "aUnsigned", "bUnsigned", "CK_NAME", "CK_KEY", "generateLicenseKey", "name", "nameBytes", "length", "padded", "buffer", "ck", "CkCipher", "outBuffer", "i", "nowVar", "encrypted", "j", "n", "b", "signed", "rotateLeft", "prefix", "suffix", "input", "s", "out", "n2", "vv", "verifyLicenseKey", "key", "checkByte", "keyHigh", "keyLow", "inputValue", "expectedPrefix", "x", "y", "shift"]
}
